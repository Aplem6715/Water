#pragma kernel SpawnParticle
#pragma kernel UpdatePressure
#pragma kernel UpdateParticle
#pragma kernel RenderParticle
#pragma kernel ClearLiquidTex

struct Particle
{
    float2 pos;
    float2 v;
    float2 v2;
    float density;
    float pressure;
    int isStatic;
    int isActive;
};

RWStructuredBuffer<Particle> _Particles;
RWTexture2D<float4> _LiquidTex;

uint _numParticles;
uint _numParticleX;
uint _numParticleY;
uint _fieldWidth;
uint _fieldHeight;
uint _numParticleAndWall;
uint _WallThickness;
int _ParticleRenderSize;
float _dt;

static const uint TexSize = 512;

static const float _ParticleSize =  0.01f;
static const float _SpaceH = _ParticleSize * 1.5f;; // 影響半径
static const float _SqrSpaceH = _SpaceH * _SpaceH;

static const float _Stiffness = 100.0f; // Stiffness 圧力係数
static const float _Density0 = 1000.0f; // density0 基本密度 
static const float _Viscosity = 1.0f; // viscosity 粘性係数 
static const float _Mass = _ParticleSize * _ParticleSize * _Density0; // 粒子質量

static const float2 _Gravity = float2(0, -9.8f);

static const float _EPSILON = 1.192092896e-07;

static const float PI = 3.14159265f;

static const float4 LiquidColor = float4(0, 0, 200, 1);

#define Poly6Alpha (4.0f / (PI * _SpaceH * _SpaceH * _SpaceH * _SpaceH * _SpaceH * _SpaceH * _SpaceH * _SpaceH))

Particle GetNewParticle(int idx)
{
    Particle newP = _Particles[idx];
    newP.isStatic = 0;
    newP.v = 0;
    newP.v2 = 0;
    newP.pressure = 0;
    newP.density = 0;
    newP.isActive = 1;
    return newP;
}

[numthreads(1, 1, 1)]
void SpawnParticle()
{
    uint width = _fieldWidth;
    uint height = _fieldHeight;
    uint x, y;

    for (y = 0; y < _numParticleY; y++)
    {
        for (x = 0; x < _numParticleX; x++)
        {
            Particle newP = GetNewParticle(x + y * _numParticleX);
            newP.pos = float2(x + _WallThickness, y + _WallThickness) * _SpaceH;
            _Particles[x + y * _numParticleX] = newP;
        }
    }

    // 左右の壁
    int wallIndex = 0;
    for (x = 0; x < _WallThickness; x++)
    {
        for(y = 0; y < height + _WallThickness; y++)
        {
            int wi = _numParticleX * _numParticleY + wallIndex;
            Particle newP = GetNewParticle(wi);
            newP.pos = float2(x, y) * _ParticleSize;
            newP.isStatic = 1;
            _Particles[wi] = newP;
            wallIndex++;

            wi = _numParticleX * _numParticleY + wallIndex;
            newP = GetNewParticle(wi);
            newP.pos = float2(x + width, y) * _ParticleSize;
            newP.isStatic = 1;
            _Particles[wi] = newP;
            wallIndex++;
        }
    }

    // 上下の壁
    for (x = 0; x < width; x++)
    {
        for (y = 0; y < _WallThickness; y++)
        {
            int wi = _numParticleX * _numParticleY + wallIndex;
            Particle newP = GetNewParticle(wi);
            newP.pos = float2(x, y) * _ParticleSize;
            newP.isStatic = 1;
            _Particles[wi] = newP;
            wallIndex++;

            wi = _numParticleX * _numParticleY + wallIndex;
            newP = GetNewParticle(wi);
            newP.pos = float2(x, y + height) * _ParticleSize;
            newP.isStatic = 1;
            _Particles[wi] = newP;
            wallIndex++;
        }
    }
}

// Poly6 Kernel
inline float DensityW(float sqrDist)
{
    float q = _SqrSpaceH - sqrDist/*== r^2*/;
    return Poly6Alpha * q * q * q;
}

[numthreads(64, 1, 1)]
void UpdatePressure(uint index : SV_DispatchThreadID)
{
    if (index >= _numParticleAndWall) return;
    if (_Particles[index].isActive == 0) return;

    float2 selfPos = _Particles[index].pos;

    float sum = 0;
    for (uint i = 0; i < _numParticleAndWall; i++)
    {
        if (_Particles[i].isActive == 0) continue;

        // 圧力計算では自分も含む
        // if (i == index) continue;
        float2 gap = _Particles[i].pos - selfPos;
        float sqrDist = dot(gap, gap);
        if (sqrDist < _SqrSpaceH)
        {
            sum += _Mass * DensityW(sqrDist);
        }
    }

    _Particles[index].density = sum;
    _Particles[index].pressure = max(_Stiffness * (sum - _Density0), 0);
}


inline float2 Ply6Grad(float rSqr, float2 gap)
{
    float q = _SqrSpaceH - rSqr;
    float c = -6 * Poly6Alpha * q * q;
    return c * gap;
}

inline float StickyW(float r)
{
    return (_SpaceH - r);
}

[numthreads(64, 1, 1)]
void UpdateParticle(uint index : SV_DispatchThreadID)
{
    if (index >= _numParticles) return;

    Particle p = _Particles[index];

    if(p.isActive == 0) return;
    if(p.isStatic == 1) return;

    float2 force = 0;
    for (uint i = 0; i < _numParticleAndWall; i++)
    {
        if (i == index) continue;
        Particle nearP = _Particles[i];
        if(nearP.isActive == 0) continue;

        float2 gap = p.pos - nearP.pos;

        float r_sqr = dot(gap, gap);
        if (r_sqr < _SqrSpaceH)
        {
            float2 wp = Ply6Grad(r_sqr, gap);
            float nearPress = nearP.pressure / (nearP.density * nearP.density);
            float pPress = p.pressure / (p.density * p.density);
            float fp = -_Mass * (nearPress + pPress);
            force += wp * fp.xx;

            float r2 = r_sqr + 0.01f + _SqrSpaceH;
            float2 dv = p.v - nearP.v;
            float fv = _Mass * 2 * _Viscosity / (nearP.density * p.density) * dot(gap, wp) / r2;
            force += fv.xx * dv;
        }
    }

    force += _Gravity;

    // リープ・フロッグ法
    p.v2 += force * _dt;
    p.pos += p.v2 * _dt;
    p.v = p.v2 + 0.5 * force * _dt;

    if(p.pos.x < -1 || p.pos.y < -1 || p.pos.x > (float)_fieldWidth+1 || p.pos.y > (float)_fieldHeight + 1)
    {
        p.isActive = 0;
    }

    _Particles[index] = p;
}

[numthreads(64, 1, 1)]
void RenderParticle(uint index : SV_DispatchThreadID)
{
    if (index >= _numParticleAndWall) return;

    Particle p = _Particles[index];

    if(p.isActive == 0) return;

    float renderScale = TexSize / ((max(_fieldWidth, _fieldHeight) + _WallThickness * 2) * _ParticleSize);
    uint2 px = uint2(p.pos * renderScale);
    // uint2 px = uint2(p.pos / _ParticleSize);
    int r = _ParticleRenderSize;
    for (int dx = -r; dx <= r; dx++)
    {
        for (int dy = -r; dy <= r; dy++)
        {
            uint2 index = px + int2(dx, dy);
            // uint2 index = px;
            if (index.x >= 0 && index.x <= TexSize && index.y >= 0 && index.y <= TexSize)
            {
                if(p.isStatic == 1)
                {
                    _LiquidTex[index] = float4(1, 1, 1, 1.0f);
                } else {
                    // float rg = (1 - p.density / _Density0) * 0.8;
                    // float b = 1.0f;
                    // _LiquidTex[index] = float4(rg, rg, b, 1.0f);
                    _LiquidTex[index] = LiquidColor;
                }
            }
        }
    }
}


[numthreads(8, 8, 1)]
void ClearLiquidTex(uint2 id : SV_DispatchThreadID)
{
    _LiquidTex[id] = float4(0, 0, 0, 0);
}
